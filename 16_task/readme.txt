1) [part1] part1_s.c, part1_c.c. Две программы: клиент и сервер, 
	которые обмениваются пакетами, используя протоколы tcp и AF_UNIX.

2) [part2] part1_s.c, part1_c.c. Две программы: клиент и сервер, 
	которые обмениваются пакетами, используя протоколы udp и AF_UNIX.

3) [part3] part3_s.c, part3_c.c. Две программы: клиент и сервер, 
	которые обмениваются пакетами, используя протоколы tcp и AF_INET.

4) [part4] part4_s.c, part4_c.c. Две программы: клиент и сервер, 
	которые обмениваются пакетами, используя протоколы udp и AF_INET.

5) [part5] part5_s.c, part5_c.c. Две программы: клиент и сервер. 
	Сервер отправляет клиенту сообщение по широковещательной рассылке,	
	используя протокол udp. (broadcast)

6) [part6] part6_s.c, part6_c.c. Две программы: клиент и сервер. 
	Сервер отправляет клиенту сообщение по групповой рассылке,	
	используя протокол udp. (multicast)

7) [part7] part7_s.c, part7_c.c. Две программы: клиент
	и сервер. "part7_s.c" выступает в роли "слушающего" сервера и принимает запросы
	от клиентов. Для каждого клиента создаётся отдельный поток, который
	будет выступать уже в роли "обслуживающего" сервера. Для обмена используются
	протоколы tcp и AF_INET.

8) [part8] part7_s.c, part7_c.c. Две программы: клиент
	и сервер. Сервер заранее создаёт несколько потоков в качестве "обслуживающих"
	серверов и назначает им уникальные порты и делает пометки, что сервера "свободны".
	После этого принимает заявку от клиента т.е. передаёт ему порт сервера(потока), который в 
	данный момент не занят и помечает сервер как "занятый". Обслуживающий сервер(поток)
	устанавливает соединение с клиентом, получает от него строку, преобразовывает её и
	отправляет обратно клиенту. Для обмена используются
	протоколы tcp и AF_INET.

9) [part9] part9_s.c, part9_c.c. Две программы: клиент
	и сервер. Сервер заранее создаёт несколько потоков в качестве "обслуживающих"
	серверов. Затем получает заявку от клиента т.е. передаёт endpoint клиента
	в очередь сообщений и любой незанятый поток, считывает это сообщение(принимает заявку).
	Обслуживающий сервер(поток) получает от клиента строку, преобразовывает её и
	отправляет обратно. Для обмена используются	протоколы tcp и AF_INET.

10) [part10] part10_s.c, part10_c_tcp.c, part10_c_udp.c. Три программы: два клиента
	и сервер. Сервер использует мультиплексирование, поэтому он может принимать сообщения
	от как от клиентов, которые используют протокол tcp, так и от клиентов, которые используют
	протокол udp. Сервер создаёт сокеты для tcp и udp протоколов и отслеживает появление нужных
	событийих, связаных с этими сокетами. После этого, в зависимости от того с каким сокетом
	произошло событие, сервер получает сообщение от клиента соответствующим, для данного
	протокола, образом.

11) [part11] part11_s.c, part11_img.png. Одна программа представляющая собой сниффер, который
	перехватывает все пакеты с протоколом udp и выводит содержимое пакетов на экран. Для
	удобства чтения трафика в программе реализована функция, которая выводит в терминал, только
	читаемые символы из пакета. Для иллюстрации работы сниффера прикреплён скриншот. На скриншоте
	показаны три терминала с результатами работ трёх программ. Две из них - это клиент и сервер,
	которые обмениваются трафиком с использованием udp протокола.(программы были взяты из
	предыдущего задания (part4)) В третьем терминале показана работа снифера, который перехватил
	трафик и вывел его на экран.

12) [part12] part12_s.c, part12_c.c. Две программы. Первая программа представляет собой сервер,
	который получает сообщение от клиента и выводит его на экран. Для получения сообщения
	используются протоколы	AF_INET и UDP. Вторая программа представляет собой клиента, который
	отправляет сообщение на	сервер. Передача сообщения происходит через raw сокет, поэтому
	программа самостоятельно формирует заголовок udp, чтобы получатель(сервер) мог корректно
	прочитать, отправленное ему сообщение.
